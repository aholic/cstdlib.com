---
layout: post
title:  "goroutine安全的带缓冲的Pipe"
date:   2015-08-16 13:58:32
categories: tech
keywords: "go, golang, goroutine安全, 线程安全, 缓冲, buffer"
description: "本文介绍了go语言中goroutine安全的带缓冲的pipe的实现"
---

#### **需求** ####
需求，最重要的就是需求，需求就是要在两个goroutine之间传递字节流，这两个goroutine分别是生产者和消费者。于是会有以下几个问题：

1. 为什么不用切片的通道(chan []byte)呢？因为想要精确的控制生产者和消费者对字节的需求，精确到字节，用切片的通道比较好的是用来控制生产者的生产次数。

2. 为什么不用标准库提供的io.Pipe呢？因为这个Pipe有点蛋疼，生产者往里写了之后，如果没有被消费者读完，就一直阻塞。

3. 为什么不用字节的通道(chan byte)呢？因为直观上来看，一字节一字节的生产消费，效率会比较低（需要实验验证）

那么在goroutine实现一个goroutine安全的buffer来协调生产者和消费者，来解决这个问题似乎比上面提到的第3点要效率高一点，于是有了本篇博客，算是个验证的实验吧。

#### **通用的接口** ####
实现的这个goroutine安全的带缓冲的pipe（以下简称ggpipe），提供read和write函数，但是参数有点神奇。
其中read能从ggpipe中的读数据，有额外的参数x和y，最少读x字节，最多读y字节，不能完成时阻塞，除非buffer被关闭。
其中write能向ggpipe中写数据，有额外的参数x和y，最少写x字节，最多写y字节，不能完成时阻塞，除非buffer被关闭。

这样描述参数x、y可能很费解，但是通过组合x、y的不同值，可以实现很多常见的读写特性，例如：

1. **`read/write x = 0， y = 10`**这样的read/write最多读/写10字节，当buffer为空的时候，直接返回。其行为类似于非阻塞的buffer，能读/写就读/写，不能读/写就返回0。

2. **`read/write x = 10, y = 10`**，最少读/写10字节，也就是说，在确定的读/写到10字节之前会阻塞。

3. **`read/write x = 1, y = 10`**，最少读/写1字节。其行为是至少要读/写数据才返回，不然阻塞。

4. **`read/write x = 10, y = 100`**，read/write至少10字节，不然阻塞。
  
好的，我觉的机智的读者已定会发现这样的read和write有其安全隐患：
假设ggpipe的预设容量是10字节，里面已经缓冲了5字节了。此时一个人调用了**`write x=6, y=...`**，表示他最少写6个字节，由于ggpipe的缓冲区只有5字节的剩余了，于是他开始阻塞，等待出现更大的缓冲区。
非常不凑巧，另一个人调用了**`read x=6, y=...`**，表示它最少读6个字节，由于ggpipe现在只能给他5字节，于是他开始阻塞了，等待里面被缓冲的数据凑够6字节。
于是他们谁也不让谁，一起阻塞，死锁了，呵呵呵。

其实想一下死锁的原因是什么呢：**`俩人的需求太大，又不肯让步`**。（此时是不是该有个禅师出来讲一下人生哲理啊？）
假设他们两个里面只要有一个谦让一点，往里写的人温和的调用**`write x=1, y=...`**或者往外读的人谦虚的调用**`read x=1, y=...`**，他们就能顺利的运行下去。

#### **Deadlock Free** ####

如何才能不死锁的阻塞？只要有一方执行read/write时，带上的参数x设为1即可，接下来说明理由。

当一个人执行**`read x=1, y=...`**，该操作还不能立即返回，那说明一定是因为ggpipe里面没有数据了（1字节都无法满足），
只要后面有人往里写数据（注意此时ggpipe里面一定没有数据，写操作一定能完成），
那么这两个人就能继续愉快的玩耍。同样的，只要有一个人执行**`write x=1, y=...`**，也一定不会引起死锁。

那么要实现**`read/write x=10, y=...`**的功能（最少读/写10字节才返回），又一定不死锁，怎么办？
很容易，只要在**`read/write x=1, y=...`**外面包一层循环，不断的执行，直到至少10字节写入在结束循环即可。
唯一的缺点是最坏的情况下会退化成1字节1字节的read，但是我觉得是非常可以接收的。

#### **实现** ####

由于最开始是为了解决标准库中io.Pipe的功能上的不足，才实现的，所以先阅读了io.Pipe实现的[源码](https://github.com/golang/go/blob/master/src/io/pipe.go)，然后实现的ggpipe，实现上也是参照了io.Pipe的，
ggpipe的代码在[这里](https://github.com/aholic/ggpipe)，其实io.Pipe和ggpipe的实现都非常短，都是200行左右的，所以代码就不多解释，直接去看源码吧。

#### **用字节的通道（chan byte）实现** ####

最开始就提到，用字节的通道可以实现累死的功能，但是直观来看性能不佳，于是我做了一个测试，测试代码在[这里](https://github.com/aholic/ggpipe/blob/master/buffered_pipe_b_test.go)。

测试结果：

    BenchmarkBufferedPipe     2000000	       946 ns/op
    BenchmarkBufferedChannel	  200000	      6914 ns/op

结果表明，用通道实现确实效率低很多，看来直观上的感受还是对的。
