---
layout: post
title:  "读《UNIX网络编程 卷1：套接字联网API》[中]"
date:   2014-10-14 11:31:32
categories: jekyll update
---

在[上一篇](/jekyll/update/2014/10/09/read-unix-network-programming-1/)中，
主要介绍了TCP的连接、断开的过程以及过程中会遇到的问题
和主机崩溃、主机重启、主机关机等不正常工作环境下TCP的工作行为。
接[上篇](/jekyll/update/2014/10/09/read-unix-network-programming-1/)，
这一篇主要介绍各种I/O模型和守护进程以及inetd的工作原理。

+ TCP和UDP的工作过程
+ TCP连接在“非正常”情况下的工作状况
+ 各种I/O模型（阻塞/非阻塞/IO复用/信号驱动/异步）
+ 守护进程和inetd的工作原理
+ 服务器程序设计范式
+ 客户端程序设计范式

#### **各种I/O模型（阻塞/非阻塞/IO复用/信号驱动/异步）** #####

+ ##### **阻塞式I/O模型** #####

  阻塞式I/O是一种很常见的I/O模型，它指的是：当所请求的I/O操作未准备好时，当前进程将被投入睡眠。
  一般都会需要切换到内核空间运行，一段时间后再切回来。默认情形下，所有套接字都是阻塞的。

+ ##### **非阻塞式I/O模型** #####

  和阻塞式I/O模型相反，它指的是：当所请求的I/O操作未准备好时，当前进程不被投入睡眠，而是返回一个错误。
  例如当套接字被设置为非阻塞时，如果在数据未准备好时，不会阻塞而是返回一个**`EWOULDBLOCK`**错误。

+ ##### **I/O复用模型** #####

  可以调用select或者poll，等待可能多个套接字中任意一个变为可读。
  可以先阻塞于select调用，等待对应套接字变为可读再对该套接字执行读操作，
  把数据从内核中复制到应用进程缓冲区中。
  事实上，因为需要两个系统调用而不是单个系统调用，I/O复用并没有什么优势，反而甚至有一些劣势。
  但是I/O复用真正的优势在于可以等待多个描述符准备就绪。
  
  为了达到和select相似的效果，还可以在多线程上使用阻塞的I/O，
  每个线程都自由的调用对于套接字的阻塞的读写操作。

+ ##### **信号驱动I/O模型** #####
  
  可以开启套接字的信号驱动式I/O功能，让内核在描述符就绪时发送**`SIGIO`**信号通知我们，
  然后通过sigaction系统调用，安装一个信号处理函数，来处理这个**`SIOIO`**信号。
  信号驱动模型的优势在于等待数据报到达期间进程不备足色，
  主循环可以继续执行，只要等待来自信号处理函数的通知即可。

+ ##### **异步I/O模型** #####
  
  它的工作机制是告知内核启动某个操作，
  并让内核在整个操作（包括把数据从内核复制到进程自己的缓冲区）完成后告知我们。
  这和信号驱动I/O模型的区别就在于：信号驱动I/O是由内核通知进程何时可以启动一个I/O操作，
  而异步I/O模型是由内核通知进程I/O操作何时完成。（POSIX异步I/O函数以aio\_或lio\_开头）。

+ ##### **总结** #####
  
  以上模型的工作过程，如下图所示：
  
  ![io-model](/image/io-model.png)

#### **守护进程和inetd工作原理** #####

+ ##### **守护进程** #####

  守护进程是在后台运行且不与任何控制终端关联的进程。
  创建一个守护进程，需要经过如下几个步骤。

  1. **创建子进程，父进程退出**
  
      一方面为了让启动父进程的shell认为该进程执行完毕；另一方面是的子进程不再是所在进程组的头进程。

  2. **在子进程中创建新会话**
  
      这样一来，当前进程变为新会话的会话头进程以及新进程组的进程组头进程，从而不再有控制终端。
      这么做主要是为了完全和父进程在会话、进程组、终端上独立。

  3. **忽略`SIGHUP`信号并且再次创建子进程**
  
      再次创建子进程是为了确保守护进程将来即使打开了一个终端设备，也不会自动获得控制终端，
      因为这个守护进程已经不再是一个会话的头进程了。
      而忽略**`SIGHUP`**的原因是：会话头进程（即第一次创建的子进程）终止时，
      会话中的所有进程（即第二次创建的子进程）会收到**`SIGHUP`**信号。

  4. **改变工作目录，切修改文件掩码**
      
      这是因为子进程会继承父进程的工作目录，会使得该目录无法卸载（unmount）。
      进程从他的父进程那里继承了文件掩码，它可能对守护进程创建的文件存取位有影响，
      为了防止这一点，应该将掩码清除。

  5. **关闭所有打开的描述符**
  
      目的是关闭本守护进程从执行它的进程继承来的所有打开着的描述符。
      但是比较困难的是检测当前正在使用的最大描述符。
      这在APUE中有详细的介绍。

  6. **将`stdin`、`stdout`、`stderr`重定向到/dev/null**
  
      这么做是以防以后调用的函数不会因为这些描述符未打开而失败。
      这种失败可能造成一些隐蔽的问题，例如被某个套接字占用而把非预期的数据发送给对端
      （**`printf`**输出到文件描述符为1的文件，但是1却是一个套接字的文件描述符）。

  7. **使用`syslogd`处理错误**
  
      总要有个能输出的地方吧，不然都不知道守护进程运行的怎么样了。


  另外，创建的守护进程在没有控制终端的环境下运行，所以一定不会收到**`SIGHUP`**信号。
  同样也绝不会收到来自内核的**`SIGINT`**和**`SIGWINCH`**信号，
  所以可以利用这些信号作为对守护进程的指示。
  当然，说了这么多，其实很多操作系统上提供了一个名为**`daemon`**函数来将一个进程转化为守护进程。

+ ##### **inetd工作原理** #####
  
  在Unix/Linux系统中，存在许多服务器，例如FTP、Telnet、ssh等。
  这些服务器进程开始都执行一样的任务：创建套接字绑定到知名端口，等待新用户，
  新用户到达时派生子进程为客户服务，父进程继续等待新用户。
  这样的话，有两方面问题：一方面是这些服务器进程长期驻留于系统，但是大部分时间其实是睡眠的，占据了进程表项；
  另一方面是这些进程包含大量的重复代码（典型的是用于进程守护化的代码和用于创建套接字的代码）。
  于是有了**`inetd`**这么一个因特网超级服务器。

  **`inetd`**进程就是利用上面的技巧，把自己变成了一个守护进程，并且读取自己的配置文件。
  它的配置文件的典型内容如下：
  
  > ftp stream tcp nowait root /usr/bin/ftpd ftpd -l
  >
  > telnet stream tcp nowait root /usr/bin/telnetd telnetd

  从以上配置文件的内容，基本能看出各项的意义，
  依次是：服务名（/etc/services文件中定义）、套接字类型、协议、等待标志、用户名、完整路径名、命令行参数。

  **`inetd`**守护进程的工作流程如下图所示：
  ![inetd_procedure](/image/inetd_procedure.png)

  1. 读取配置文件，为配置文件中的每一行的内容创建一个套接字，
     并且绑定到对应端口上（如果是TCP套接字，还要调用listen），
     最后由一起阻塞于一个select调用上。
  2. 新客户到达时，fork一个子进程为其服务。
     父进程回到select继续等待新客户
     （如果是TCP连接，需要close原套接字，如果不close的话，那么父进程的select将先于子进程的检查，会引发问题）。
     而子进程需要关闭除了该套接字以外的所有进程，
     并且将该套接字dup到文件描述符0、1、2。
     那么子进程面对的就只有标准输入、标准输出和标准错误了。
  3. 如果配置文件中的登录名不是root，
     子进程还需要调用setgid和setuid把自己编程指定的用户
     （因为inetd进程的用户id是0，所以子进程最初也是这个id，所以可以变成选定的任何用户）。
  4. 最后再去exec服务器程序即可。

  所以总得来看，**`inetd`**进程就像是一个连接的分发器，为我们编写的服务器程序屏蔽了进程守护化和套接字打开关闭等细节而只需要面对标准输入输出。
  但是**`inetd`**这样为每个新来的用户创建一个进程的模式，不适合服务密集型的服务器，
  因为每个新客户的开销是一个fork加一个exec。
  Web服务器需要使用多种技术把每个客户链接的开销降到最低，这将在下一篇中详细论述。
