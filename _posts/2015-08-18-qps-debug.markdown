---
layout: post
title:  "一次查问题的经历"
date:   2015-08-18 02:09:00
categories: tech
keywords: "debug, qps"
description: "本文描述了一次查找服务器问题的经历"
---

#### **问题描述** #####

问题是这样的，在HTTP服务器回复的response里面，加入了一个用来debug的header，引起了qps的大幅下降。详细参数：加入debug header之前，qps是200K，cpu利用率几乎100%；加入debug header之后，qps降到了80K，cpuu利用率只有60%了。此时服务器起的是24线程工作的。


#### **初步猜测** #####

1. 查看header发送部分的代码，发现调用了一次内存非配函数，来存储该response，所以可能的问题是加入了debug header之后，需要的内存打了一些，导致内存分配时恰好遇到了对齐的问题。
2. 加入debug header之后，qps严重下降，同时cpu也不能满载，qps下降幅度超过了cpu利用率的下降幅度，说明是一些IO事件降低了cpu利用率。

#### **参数调整** ####

为了让qps成为客观的指标，即cpu能满载，所以将服务器的工作线程数设为1，调整之后的数据参数是：加入debug header之前，qps是23K，cpu几乎满载；加入debug header之后，qps降到了21K，cpu几乎满载。

#### **验证猜想** ####

1. 刚开始以为是内存分配的问题，所以测试了很多种加入的debug header的长度，发现其长度由9字节变为10字节的时候，qps产生了突然的降幅。为了验证是不是内存对其等问题引起的，继续测试了很多种debug header的长度的影响，发现自10之后继续增大或者是自9之前继续减小debug header的长度，qps不再出现突变。此时我基本已经忘了另一个猜测了，非常不理智，一直在试各种debug header的长度，基本处于“明知道没结果，但是还是要试一试”的状态。直到，在debug header小于阈值（9字节），然后在分配内存传入内存大小参数的时候，强行调大内存的需求，qps依然不下降，遂排除了内存分配问题的影响。
2. 终于开始考虑猜测2了，主要是看发出的HTTP response的大小带来的影响，所以要把网络实际发送和内存分配两处涉及的字节数分开，及在debug header较大的情况下，强行减少网络发送的字节，发现qps竟然出现了提升，所以初步断定就是网络IO的问题引起的。

#### **守得云开见月明** ####

于是开始使用tcpdump开始抓包，发现了问题：当debug header的长度为9字节时，tcp数据包的大小恰好为1460，这个数字我就不多解释了，懂的自然懂。当debug header再长一字节，一个HTTP response不能被一个TCP包完整的负载，是通过两个TCP包发出去的，从而引起了qps的降低的问题

#### **总结** ####

当一条路走不下去的时候，跳出来想想，会不会是其他的问题。